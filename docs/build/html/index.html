
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Welcome to SKA-low mini project’s documentation! &#8212; SKA-low mini project  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-ska-low-mini-project-s-documentation">
<h1>Welcome to SKA-low mini project’s documentation!<a class="headerlink" href="#welcome-to-ska-low-mini-project-s-documentation" title="Permalink to this heading">¶</a></h1>
<section id="harp-beam">
<h2>harp_beam<a class="headerlink" href="#harp-beam" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.legendre">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">legendre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.legendre" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the associated Legendre function for integer orders and degree at value x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>float</em>) – Degree of the Legendre function.</p></li>
<li><p><strong>x</strong> (<em>float</em>) – Position to evaluate function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>return</strong> (<em>np.array</em>)</p></li>
<li><p><em>Legendre function for all integer orders from 0 to deg.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.legendre3">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">legendre3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.legendre3" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all associated Legendre functions up to max order n at value x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>float</em>) – Max degree of the Legendre function.</p></li>
<li><p><strong>x</strong> (<em>float</em>) – Position to evaluate function</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>return</strong> (<em>np.array</em>)</p></li>
<li><p><em>Legendre functions (Pnm,Pnm/costheta,dPnmdsintheta) for all</em></p></li>
<li><p><em>integer orders from 0 to deg.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.smodes_eval">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">smodes_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_tm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_te</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.smodes_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spherical wave modes TE and TM according to definitions in
the book J.E. Hansen, Spherical near-field measurements</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order</strong> (<em>float</em>) – Max order of the Legendre function.</p></li>
<li><p><strong>alpha_tm</strong> (<em>np.array</em><em>, </em><em>complex double</em>) – coefficients for TM modes, 3d array of size
(num_mbf, 2 * max_order + 1, max_order)</p></li>
<li><p><strong>alpha_te</strong> (<em>np.array</em><em>, </em><em>complex double</em>) – coefficients for TE modes, 3d array of size
(num_mbf, 2 * max_order + 1, max_order)</p></li>
<li><p><strong>theta</strong> (<em>np.araay</em><em>, </em><em>float</em>) – zenith angle</p></li>
<li><p><strong>phi</strong> (<em>np.array</em><em>, </em><em>float</em>) – azimuth angle</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>return</strong> (<em>np.array, complex double</em>)</p></li>
<li><p><em>gvv</em></p></li>
<li><p><em>ghh</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.wrapTo2Pi">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">wrapTo2Pi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.wrapTo2Pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the given angle phi to the range [0, 2*pi).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>phi</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Angle or array of angles in radians.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>wrapped_phi</strong> – Angle(s) wrapped to the range [0, 2*pi).
The returned value has the same type as the input <cite>phi</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.compute_EEPs">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">compute_EEPs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_te</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_tm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs_polX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_ant</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_mbf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.compute_EEPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Equivalent Electric Field Patterns (EEPs) for a
given antenna array configuration, considering both TE and TM modes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> (<em>np.ndarray</em>) – Array of elevation angles in radians, where negative values are
reflected and wrapped accordingly.</p></li>
<li><p><strong>phi</strong> (<em>np.ndarray</em>) – Array of azimuth angles in radians, wrapped to the range [0, 2*pi)
for negative theta.</p></li>
<li><p><strong>alpha_te</strong> (<em>np.ndarray</em>) – Coefficients for TE modes, reshaped according to
‘num_mbf’, ‘max_order’, and beam directions.</p></li>
<li><p><strong>alpha_tm</strong> (<em>np.ndarray</em>) – Coefficients for TM modes, similarly reshaped.</p></li>
<li><p><strong>coeffs_polX</strong> (<em>np.ndarray</em>) – Coefficients for polarisation X, considering antenna positions
and mode basis functions (MBFs).</p></li>
<li><p><strong>coeffs_polY</strong> (<em>np.ndarray</em>) – Coefficients for polarisation Y, with a similar structure to
‘coeffs_polX’.</p></li>
<li><p><strong>pos_ant</strong> (<em>np.ndarray</em>) – Positions of the antennas in the array.</p></li>
<li><p><strong>num_mbf</strong> (<em>int</em>) – Number of mode basis functions.</p></li>
<li><p><strong>max_order</strong> (<em>int</em>) – Maximum order of the modes.</p></li>
<li><p><strong>k0</strong> (<em>float</em>) – Wave number in free space.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>v_theta_polY</strong> (<em>np.ndarray</em>) – Vertical component of the electric field pattern for polarisation Y.</p></li>
<li><p><strong>v_phi_polY</strong> (<em>np.ndarray</em>) – Horizontal component of the electric field pattern for polarisation Y.</p></li>
<li><p><strong>v_theta_polX</strong> (<em>np.ndarray</em>) – Vertical component of the electric field pattern for polarisation X.</p></li>
<li><p><strong>v_phi_polX</strong> (<em>np.ndarray</em>) – Horizontal component of the electric field pattern for polarisation X.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function computes the EEPs by first correcting the input angles and
then calculating the field components using the provided mode coefficients,
antenna positions, and the wave number. The output patterns are
provided for each polarisation and direction.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.to_dBV">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">to_dBV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.to_dBV" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a given magnitude to decibels relative to 1 volt (dBV).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>magnitude</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – The magnitude (or array of magnitudes) of the signals whose level is to
be converted to dBV.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The level of the input magnitudes expressed in dBV.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.power_EEPs">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">power_EEPs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_theta_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_phi_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_theta_polX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_phi_polX</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.power_EEPs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power Embedding Element Patterns (EEP) for
two polarizations (X and Y) and convert these patterns and their
averages (AEPs) to dBV.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_theta_polY</strong> (<em>np.ndarray</em>) – The vertical component of the electric field pattern for polarisation Y.</p></li>
<li><p><strong>v_phi_polY</strong> (<em>np.ndarray</em>) – The horizontal component of the electric field pattern for polarisation Y.</p></li>
<li><p><strong>v_theta_polX</strong> (<em>np.ndarray</em>) – The vertical component of the electric field pattern for polarisation X.</p></li>
<li><p><strong>v_phi_polX</strong> (<em>np.ndarray</em>) – The horizontal component of the electric field pattern for polarisation X.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>EEPs_polY_dBV</strong> (<em>np.ndarray</em>) – EEPs for polarisation Y in dBV.</p></li>
<li><p><strong>EEPs_polX_dBV</strong> (<em>np.ndarray</em>) – EEPs for polarisation X in dBV.</p></li>
<li><p><strong>AEP_polY_dBV</strong> (<em>np.ndarray</em>) – Average EEP for polarisation Y in dBV.</p></li>
<li><p><strong>AEP_polX_dBV</strong> (<em>np.ndarray</em>) – Average EEP for polarisation X in dBV.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function calculates the magnitude of the EEPs for each component
and polarisation, computes the total EEPs by summing the squared
magnitudes of the vertical and horizontal components and calculates
the average EEPs (AEPs) across all directions.
It then converts these values to dBV using the <cite>to_dBV</cite> function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.stefcal">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">stefcal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g_sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.stefcal" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the StEFCal (Simplified Tikhonov-based Efficient Calibration)
algorithm to solve for the complex gain solutions of an antenna array in
radio interferometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>np.ndarray</em>) – The measured visibility matrix, representing the cross-correlations between
antennas’ signals.</p></li>
<li><p><strong>R</strong> (<em>np.ndarray</em>) – The model visibility matrix, derived from a known sky model and representing
expected correlations.</p></li>
<li><p><strong>g_sol</strong> (<em>np.ndarray</em>) – The true gain solutions for the antennas, used to compute errors for
convergence analysis.</p></li>
<li><p><strong>max_iteration</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of iterations to run the algorithm for.
Default is 1000.</p></li>
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – The convergence threshold, used to determine when the algorithm has
sufficiently converged. Default is 1e-5.</p></li>
<li><p><strong>algorithm2</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to determine which version of the algorithm to use. If False, uses G[i-1]
for calculations; if True, uses G[i]. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><em>tuple</em> –</p>
<dl class="simple">
<dt>G<span class="classifier">np.ndarray</span></dt><dd><p>The final estimated gains matrix, where each diagonal element represents the
gain for one antenna.</p>
</dd>
<dt>convergence<span class="classifier">list</span></dt><dd><p>A list of convergence values, one for every second iteration, measuring the
relative change in G.</p>
</dd>
<dt>abs_gain_error<span class="classifier">list</span></dt><dd><p>A list of the absolute gain errors, measuring the difference between the
estimated and true gains.</p>
</dd>
<dt>abs_amp_error<span class="classifier">list</span></dt><dd><p>A list of the absolute amplitude errors, comparing the magnitudes of the
estimated and true gains.</p>
</dd>
<dt>abs_phase_error<span class="classifier">list</span></dt><dd><p>A list of the absolute phase errors, comparing the phases of the
estimated and true gains.</p>
</dd>
</dl>
</li>
<li><p><em>The function iteratively updates the gain solutions by minimising the difference</em></p></li>
<li><p><em>between the measured and model visibilities, adjusting the gains to better fit the</em></p></li>
<li><p><em>model to the measurements. Convergence is checked every second iteration and various</em></p></li>
<li><p><em>errors are calculated to evaluate the accuracy of the</em></p></li>
<li><p><em>gain estimates.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.beamforming">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">beamforming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G_diag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EEP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_ant</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.beamforming" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform beamforming to compute the array pattern for a given steering direction
(theta0, phi0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G_diag</strong> (<em>np.ndarray</em>) – The diagonal elements of the gains matrix, representing the gain for each
antenna.</p></li>
<li><p><strong>EEP</strong> (<em>np.ndarray</em>) – The Equivalent Electric Field Pattern for the antennas in the array for a
specific polarization.</p></li>
<li><p><strong>pos_ant</strong> (<em>np.ndarray</em>) – The positions of the antennas in the array.</p></li>
<li><p><strong>k</strong> (<em>float</em>) – The wave number in free space.</p></li>
<li><p><strong>theta</strong> (<em>np.ndarray</em>) – The elevation angles for which the array pattern is computed.</p></li>
<li><p><strong>phi</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – The azimuth angle(s) for which the array pattern is computed.
Can be a scalar or an array.</p></li>
<li><p><strong>theta0</strong> (<em>float</em>) – The elevation angle of the steering direction.</p></li>
<li><p><strong>phi0</strong> (<em>float</em>) – The azimuth angle of the steering direction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>np.ndarray</em> – The computed array pattern for the specified theta and phi.
The array is 1D if phi is a scalar, or 2D if phi is an array,
corresponding to the meshgrid formed by theta and phi.</p></li>
<li><p><em>The function calculates the beamforming pattern by applying phase shifts to</em></p></li>
<li><p><em>the EEPs based on the antenna positions and the desired steering direction.</em></p></li>
<li><p><em>It accounts for both scalar and array inputs for the azimuth angle phi.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.harp_beam.compute_beamforming">
<span class="sig-prename descclassname"><span class="pre">src.harp_beam.</span></span><span class="sig-name descname"><span class="pre">compute_beamforming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_theta_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_phi_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_theta_polX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_phi_polX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_ant</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.harp_beam.compute_beamforming" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the beamforming patterns for both Y and X polarisations
and convert the results to dBV.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>np.ndarray</em>) – The gains matrix for the antennas in the array, with diagonal elements
representing the gains per antenna.</p></li>
<li><p><strong>v_theta_polY</strong> (<em>np.ndarray</em>) – The vertical component of the electric field pattern for polarisation Y.</p></li>
<li><p><strong>v_phi_polY</strong> (<em>np.ndarray</em>) – The horizontal component of the electric field pattern for polarisation Y.</p></li>
<li><p><strong>v_theta_polX</strong> (<em>np.ndarray</em>) – The vertical component of the electric field pattern for polarisation X.</p></li>
<li><p><strong>v_phi_polX</strong> (<em>np.ndarray</em>) – The horizontal component of the electric field pattern for polarisation X.</p></li>
<li><p><strong>pos_ant</strong> (<em>np.ndarray</em>) – The positions of the antennas in the array.</p></li>
<li><p><strong>k</strong> (<em>float</em>) – The wave number in free space.</p></li>
<li><p><strong>theta</strong> (<em>np.ndarray</em>) – The elevation angles for which the array pattern is computed.</p></li>
<li><p><strong>phi</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – The azimuth angle(s) for which the array pattern is computed.
Can be a scalar or an array.</p></li>
<li><p><strong>theta0</strong> (<em>float</em>) – The elevation angle of the steering direction.</p></li>
<li><p><strong>phi0</strong> (<em>float</em>) – The azimuth angle of the steering direction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>tuple of np.ndarray</em> – The computed array patterns for polarisations Y and X, converted to dBV.
Each pattern is 1D if phi is a scalar, or 2D if phi is an array,
corresponding to the meshgrid formed by theta and phi.</p></li>
<li><p>This function utilises the <cite>beamforming</cite> function to calculate the array patterns</p></li>
<li><p><em>for both Y and X polarisations based on the provided EEPs and gains.</em></p></li>
<li><p><em>It then computes the absolute patterns and converts them to dBV.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="utils">
<h2>utils<a class="headerlink" href="#utils" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="src.utils.compute_k0">
<span class="sig-prename descclassname"><span class="pre">src.utils.</span></span><span class="sig-name descname"><span class="pre">compute_k0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.utils.compute_k0" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the wavenumber (k0) given the frequency and the speed of light.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<em>float</em>) – The frequency of operation in MHz (Megahertz).</p></li>
<li><p><strong>c0</strong> (<em>float</em>) – The speed of light in a vacuum, typically 299792458 meters per second.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The wavenumber corresponding to the given frequency and speed of light,
calculated as k0 = 2 * pi * freq / c0, where freq is converted from MHz to Hz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.utils.load_antenna_data">
<span class="sig-prename descclassname"><span class="pre">src.utils.</span></span><span class="sig-name descname"><span class="pre">load_antenna_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.utils.load_antenna_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads antenna configuration data from a MATLAB .mat file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The path to the .mat file containing antenna configuration data.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>max_order<span class="classifier">int</span></dt><dd><p>The maximum order of the modes used in the antenna configuration.</p>
</dd>
<dt>num_mbf<span class="classifier">int</span></dt><dd><p>The number of mode basis functions.</p>
</dd>
<dt>coeffs_polX<span class="classifier">np.ndarray</span></dt><dd><p>Coefficients for polarisation X.</p>
</dd>
<dt>coeffs_polY<span class="classifier">np.ndarray</span></dt><dd><p>Coefficients for polarisation Y.</p>
</dd>
<dt>alpha_te<span class="classifier">np.ndarray</span></dt><dd><p>Coefficients for transverse electric (TE) modes.</p>
</dd>
<dt>alpha_tm<span class="classifier">np.ndarray</span></dt><dd><p>Coefficients for transverse magnetic (TM) modes.</p>
</dd>
<dt>pos_ant<span class="classifier">np.ndarray</span></dt><dd><p>Positions of the antennas in the array.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.utils.load_arrays_from_mat">
<span class="sig-prename descclassname"><span class="pre">src.utils.</span></span><span class="sig-name descname"><span class="pre">load_arrays_from_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.utils.load_arrays_from_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads specified arrays from a MATLAB .mat file, typically used
in signal processing or antenna array simulations,
into a Python dictionary for easy access.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The path to the .mat file from which the data is to be loaded.
This file is expected to contain specific matrices that represent
various parameters or results from simulations or experimental setups
in the context of signal processing or antenna array analysis.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary containing the following key-value pairs:
- ‘R’: np.ndarray, the covariance matrix representing signal or
noise correlations between array elements.
- ‘M_AEP’: np.ndarray, the model matrix derived using the
Average Electric Field Pattern (AEP).
- ‘M_EEPs’: np.ndarray, the model matrix derived using all
Equivalent Electric Field Patterns (EEPs).
- ‘g_sol’: np.ndarray, the exact gain solution, typically used
as a reference or true value.
- ‘g_AEP’: np.ndarray, the gain estimation derived from the
‘M_AEP’ model matrix.
- ‘g_EEPs’: np.ndarray, the gain estimation derived from the
‘M_EEPs’ model matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="plot-utils">
<h2>plot_utils<a class="headerlink" href="#plot-utils" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="src.plot_utils.plot_power_EEPs_and_AEP">
<span class="sig-prename descclassname"><span class="pre">src.plot_utils.</span></span><span class="sig-name descname"><span class="pre">plot_power_EEPs_and_AEP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnitude_EEP_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnitude_EEP_polX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AEP_polY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AEP_polX</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.plot_utils.plot_power_EEPs_and_AEP" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the Equivalent Electric Field Patterns (EEPs) and
Average Electric Field Patterns (AEPs) for Y and X polarizations.</p>
<dl class="simple">
<dt>theta<span class="classifier">np.ndarray</span></dt><dd><p>The angular positions (in radians) at which the EEPs and AEPs are evaluated,
ypically covering -pi/2 to pi/2 (or -90 to 90 degrees).</p>
</dd>
<dt>magnitude_EEP_polY<span class="classifier">np.ndarray</span></dt><dd><p>The magnitudes of the EEPs for Y polarisation across the
specified theta angles for each antenna element.</p>
</dd>
<dt>magnitude_EEP_polX<span class="classifier">np.ndarray</span></dt><dd><p>The magnitudes of the EEPs for X polarisation across the
specified theta angles for each antenna element.</p>
</dd>
<dt>AEP_polY<span class="classifier">np.ndarray</span></dt><dd><p>The magnitude of the AEP for Y polarisation, averaged over all antenna elements.</p>
</dd>
<dt>AEP_polX<span class="classifier">np.ndarray</span></dt><dd><p>The magnitude of the AEP for X polarisation, averaged over all antenna elements.</p>
</dd>
</dl>
<p>This function generates two plots, one for each polarisation (Y and X), s
howing the variation of the electric field with the angle theta.
The EEPs for each antenna element are plotted with partial transparency
to visualise their distribution, while the AEP is highlighted as a distinct,
solid line for each polarisation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.plot_utils.plot_stefcal_comparison">
<span class="sig-prename descclassname"><span class="pre">src.plot_utils.</span></span><span class="sig-name descname"><span class="pre">plot_stefcal_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algo1_AEP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo1_EEPs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo2_AEP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo2_EEPs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.plot_utils.plot_stefcal_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares and visualises the convergence and error metrics for
two different calibration algorithms using AEP and EEP data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algo1_AEP</strong> (<em>tuple</em>) – A tuple containing convergence data and error metrics
(absolute, amplitude, phase) for Algorithm 1 using AEP data.</p></li>
<li><p><strong>algo1_EEPs</strong> (<em>tuple</em>) – A tuple containing convergence data and error metrics for
Algorithm 1 using EEP data.</p></li>
<li><p><strong>algo2_AEP</strong> (<em>tuple</em>) – A tuple containing convergence data and error metrics for
Algorithm 2 using AEP data.</p></li>
<li><p><strong>algo2_EEPs</strong> (<em>tuple</em>) – A tuple containing convergence data and error metrics for
Algorithm 2 using EEP data.</p></li>
<li><p><strong>algorithms.</strong> (<em>This function generates a series of plots to compare two calibration</em>) – </p></li>
<li><p><strong>visualises</strong> (<em>It</em>) – </p></li>
<li><p><strong>data.</strong> (<em>- The convergence trends for both algorithms using AEP and EEP</em>) – </p></li>
<li><p><strong>errors</strong> (<em>- The phase</em>) – </p></li>
<li><p><strong>estimations</strong> (<em>showcasing how closely each algorithm's gain</em>) – </p></li>
<li><p><strong>gains.</strong> (<em>gains relative to the true</em>) – </p></li>
<li><p><strong>errors</strong> – </p></li>
<li><p><strong>the</strong> (<em>illustrating the differences in the magnitude of</em>) – </p></li>
<li><p><strong>gains.</strong> – </p></li>
<li><p><strong>errors</strong> – </p></li>
<li><p><strong>estimated</strong> (<em>demonstrating the discrepancies in the phase of the</em>) – </p></li>
<li><p><strong>gains.</strong> – </p></li>
<li><p><strong>comprehensive</strong> (<em>The comparison is done across several metrics to provide a</em>) – </p></li>
<li><p><strong>assessment</strong> (<em>overview of each algorithm's performance and to facilitate the</em>) – </p></li>
<li><p><strong>estimation.</strong> (<em>of their convergence behavior and accuracy in gain</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.plot_utils.plot_beamforming_results">
<span class="sig-prename descclassname"><span class="pre">src.plot_utils.</span></span><span class="sig-name descname"><span class="pre">plot_beamforming_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polY_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polX_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linestyles</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.plot_utils.plot_beamforming_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the beamforming results for both Y and X polarisations over a
specified range of theta values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta_range</strong> (<em>np.ndarray</em>) – The range of theta values (in radians) over which the beamforming data is
plotted. These values typically span from -pi/2 to pi/2 to cover the full
angular span in the elevation plane.</p></li>
<li><p><strong>polY_data</strong> (<em>list of np.ndarray</em>) – A list containing the data arrays for Y polarisation. Each array corresponds
to a different beamforming result or condition to be plotted.</p></li>
<li><p><strong>polX_data</strong> (<em>list of np.ndarray</em>) – A list containing the data arrays for X polarisation, structured similarly to
<cite>polY_data</cite>.</p></li>
<li><p><strong>labels</strong> (<em>list of str</em>) – A list of labels corresponding to each data array in <cite>polY_data</cite> and
<cite>polX_data</cite>, used for the plot legend.</p></li>
<li><p><strong>linestyles</strong> (<em>list of str</em>) – A list of matplotlib linestyles corresponding to each data array,
used to differentiate the plotted lines.</p></li>
<li><p><strong>plots</strong> (<em>The function generates two separate</em>) – </p></li>
<li><p><strong>for</strong> (<em>one for Y polarisation and another</em>) – </p></li>
<li><p><strong>conditions</strong> (<em>X polarisation. Each plot displays multiple beamforming results or</em>) – </p></li>
</ul>
</dd>
</dl>
<p>:param :
:param differentiated by linestyles and annotated with a legend.:</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.plot_utils.plot_station_beam_pattern">
<span class="sig-prename descclassname"><span class="pre">src.plot_utils.</span></span><span class="sig-name descname"><span class="pre">plot_station_beam_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">APy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">APx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'$\\sin(\\theta)\\cos(\\phi)$'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'$\\sin(\\theta)\\sin(\\phi)$'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Intensity</span> <span class="pre">[dBV]'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.plot_utils.plot_station_beam_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the station beam patterns for Y and X polarisations using color-mapped
intensity data over a 2D spatial grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – 2D array of X-coordinates for the meshgrid over which the station beam patterns
are plotted. Typically represents the sine of the elevation angle multiplied
by the cosine of the azimuth angle.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – 2D array of Y-coordinates for the meshgrid, corresponding to <cite>x</cite>.
Typically represents the sine of the elevation
angle multiplied by the sine of the azimuth angle.</p></li>
<li><p><strong>APy</strong> (<em>np.ndarray</em>) – The antenna pattern data for Y polarisation to be visualised,
mapped onto the meshgrid defined by <cite>x</cite> and <cite>y</cite>.</p></li>
<li><p><strong>APx</strong> (<em>np.ndarray</em>) – The antenna pattern data for X polarisation, structured similarly to <cite>APy</cite>.</p></li>
<li><p><strong>xlabel</strong> (<em>str</em><em>, </em><em>optional</em>) – Label for the x-axis of the plots. Defaults to representing the
mathematical expression for <cite>x</cite>.</p></li>
<li><p><strong>ylabel</strong> (<em>str</em><em>, </em><em>optional</em>) – Label for the y-axis of the plots. Defaults to representing the
mathematical expression for <cite>y</cite>.</p></li>
<li><p><strong>intensity_label</strong> (<em>str</em><em>, </em><em>optional</em>) – Label for the colorbar indicating the intensity scale.
Defaults to ‘Intensity [dBV]’.</p></li>
<li><p><strong>cmap</strong> (<em>str</em><em>, </em><em>optional</em>) – Colormap used for the pcolormesh plots. Defaults to ‘viridis’.</p></li>
<li><p><strong>the</strong> (<em>This function creates two side-by-side color-mesh plots representing</em>) – </p></li>
<li><p><strong>polarisations</strong> (<em>station beam patterns for Y and X</em>) – </p></li>
<li><p><strong>respectively.</strong> – </p></li>
<li><p><strong>specified</strong> (<em>The intensity of the beam patterns is color-coded according to the</em>) – </p></li>
<li><p><strong>colormap</strong> – </p></li>
<li><p><strong>scale.</strong> (<em>with a colorbar indicating the intensity</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">SKA-low mini project</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Max Talberg.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>